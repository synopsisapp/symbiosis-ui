import path from "path";
import { glob } from "glob";
import { parse } from "node-html-parser";
import fsExtra from "fs-extra";
import { fileURLToPath } from "url";

type Options = {
  inputDir: string;
  outputDir: string;
  verboseLogs: boolean;
};

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export async function generateIcons(options: Options) {
  if (!path || !fsExtra || !glob) {
    if (!path) {
      console.warn("Path module is not available in this environment.");
    }

    if (!fsExtra) {
      console.warn("fs-extra module is not available in this environment.");
    }

    if (!glob) {
      console.warn("Glob module is not available in this environment.");
    }

    console.warn("Icon generation is not available in this environment.");
    return;
  }

  const cwd = process.cwd();
  const inputDir = path.join(cwd, options.inputDir || "assets/icons");
  const internalInputDir = path.resolve(__dirname, "../../internal-assets");
  const inputDirRelative = path.relative(cwd, inputDir);
  const outputDir = path.join(cwd, options.outputDir, "symbiosis-assets");

  await fsExtra.ensureDir(outputDir);

  const files = glob
    .sync("**/*.svg", {
      cwd: inputDir,
    })
    .sort((a: string, b: string) => a.localeCompare(b));

  const internalFiles = glob
    .sync("**/*.svg", {
      cwd: internalInputDir,
    })
    .sort((a: string, b: string) => a.localeCompare(b));

  const logVerbose = options.verboseLogs ? console.log : () => {};

  if (files.length === 0 && internalFiles.length === 0) {
    console.log(`No SVG files found in ${inputDirRelative}`);
    await generateEmptyIconFiles(outputDir);
  } else {
    await generateIconFiles(
      files,
      internalFiles,
      inputDir,
      internalInputDir,
      outputDir,
      cwd,
      inputDirRelative,
      logVerbose,
    );
  }
}

async function generateEmptyIconFiles(outputDir: string) {
  const typeOutputFilepath = path.join(outputDir, "types.d.ts");
  const jsonOutputFilepath = path.join(outputDir, "iconNames.json");
  const spriteFilepath = path.join(outputDir, "sprite.svg");

  const typeOutputContent = `// This file is generated by npm run build:icons

  declare namespace SymbiosisUI {
    type IconName = string;
    const IconNames: readonly IconName[];
  }
  `;

  await fsExtra.writeFile(typeOutputFilepath, typeOutputContent);
  await fsExtra.writeJson(jsonOutputFilepath, [], { spaces: 2 });
  await fsExtra.writeFile(spriteFilepath, '<svg xmlns="http://www.w3.org/2000/svg"></svg>');

  console.log("Generated empty icon files");
}

async function generateIconFiles(
  files: string[],
  internalFiles: string[],
  inputDir: string,
  internalInputDir: string,
  outputDir: string,
  cwd: string,
  inputDirRelative: string,
  logVerbose: (...args: unknown[]) => void,
) {
  const spriteFilepath = path.join(outputDir, "sprite.svg");
  const typeOutputFilepath = path.join(outputDir, "types.d.ts");
  const jsonOutputFilepath = path.join(outputDir, "iconNames.json");

  const currentSprite = await fsExtra.readFile(spriteFilepath, "utf8").catch(() => "");
  const currentTypes = await fsExtra.readFile(typeOutputFilepath, "utf8").catch(() => "");

  const iconNames = [
    ...files.map((file: string) => iconName(file)),
    ...internalFiles.map((file: string) => iconName(file)),
  ];

  const spriteUpToDate = iconNames.every((name: string) => currentSprite.includes(`id=${name}`));
  const typesUpToDate = iconNames.every((name: string) => currentTypes.includes(`"${name}"`));

  if (spriteUpToDate && typesUpToDate) {
    logVerbose("Icons are up to date");
    return;
  }

  logVerbose(`Generating sprite for ${inputDirRelative}`);

  const spriteChanged = await generateSvgSprite({
    files,
    internalFiles,
    inputDir,
    internalInputDir,
    outputPath: spriteFilepath,
  });

  for (const file of files) {
    logVerbose("✅", file);
  }
  for (const file of internalFiles) {
    logVerbose("✅ (internal)", file);
  }
  logVerbose(`Saved to ${path.relative(cwd, spriteFilepath)}`);

  const stringifiedIconNames = iconNames.map((name: string) => JSON.stringify(name));

  const typeOutputContent = `// This file is generated by npm run build:icons

declare namespace SymbiosisUI {
  type IconName =
    | ${stringifiedIconNames.join("\n    | ")}

  const IconNames: readonly IconName[];
}
`;

  const typesChanged = await writeIfChanged(typeOutputFilepath, typeOutputContent);

  logVerbose(`Manifest saved to ${path.relative(cwd, typeOutputFilepath)}`);

  const readmeChanged = await writeIfChanged(
    path.join(outputDir, "README.md"),
    `# Icons

This directory contains SVG icons that are used by the app.

## Icon names

\`\`\`json
${JSON.stringify(iconNames, null, 2)}
\`\`\`

Everything in this directory is generated by \`pnpm run build:icons\`.
`,
  );

  await fsExtra.writeJson(jsonOutputFilepath, iconNames, { spaces: 2 });
  logVerbose(`Icon names saved to ${path.relative(cwd, jsonOutputFilepath)}`);

  if (spriteChanged || typesChanged || readmeChanged) {
    console.log(`Generated ${files.length + internalFiles.length} icons`);
  }
}

function iconName(file: string) {
  return file.replace(/\.svg$/, "");
}

async function generateSvgSprite({
  files,
  internalFiles,
  inputDir,
  internalInputDir,
  outputPath,
}: {
  files: string[];
  internalFiles: string[];
  inputDir: string;
  internalInputDir: string;
  outputPath: string;
}) {
  const symbols = await Promise.all([
    ...files.map(async (file) => generateSymbol(file, inputDir)),
    ...internalFiles.map(async (file) => generateSymbol(file, internalInputDir)),
  ]);

  let output = [
    `<?xml version="1.0" encoding="UTF-8"?>`,
    "<!-- This file is generated by npm run build:icons -->",
    `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">`,
    "<defs>",
    ...symbols,
    "</defs>",
    "</svg>",
    "",
  ].join("\n");

  if (Buffer.byteLength(output, "utf8") < 4096) {
    const placeholderSVG = `
  <symbol id="placeholder" viewBox="0 0 1 1">
    <path d="M0,0 L1,1 M1,0 L0,1" stroke="transparent" />
  </symbol>`.repeat(20);

    output = output.replace("</defs>", `${placeholderSVG}</defs>`);
  }

  return writeIfChanged(outputPath, output);
}

async function generateSymbol(file: string, inputDir: string) {
  const input = await fsExtra.readFile(path.join(inputDir, file), "utf8");
  const root = parse(input);

  const svg = root.querySelector("svg");
  if (!svg) throw new Error("No SVG element found");

  svg.tagName = "symbol";
  svg.setAttribute("id", iconName(file));
  svg.removeAttribute("xmlns");
  svg.removeAttribute("xmlns:xlink");
  svg.removeAttribute("version");
  svg.removeAttribute("width");
  svg.removeAttribute("height");
  svg.removeAttribute("class");

  return svg.toString().trim();
}

async function writeIfChanged(filepath: string, newContent: string) {
  const currentContent = await fsExtra.readFile(filepath, "utf8").catch(() => "");
  if (currentContent === newContent) return false;
  await fsExtra.writeFile(filepath, newContent, "utf8");
  return true;
}
