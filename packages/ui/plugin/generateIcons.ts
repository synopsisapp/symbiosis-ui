import path from "path";
import { glob } from "glob";
import { parse } from "node-html-parser";
import fsExtra from "fs-extra";

type Options = {
  inputDir: string;
  outputDir: string;
};

export async function generateIcons(options: Options) {
  console.log("Generating icons");
  if (!path || !fsExtra || !glob) {
    if (!path) {
      console.warn("Path module is not available in this environment.");
    }

    if (!fsExtra) {
      console.warn("fs-extra module is not available in this environment.");
    }

    if (!glob) {
      console.warn("Glob module is not available in this environment.");
    }

    console.warn("Icon generation is not available in this environment.");
    return;
  }

  const cwd = process.cwd();
  const inputDir = path.join(cwd, options.inputDir || "assets/icons");
  const inputDirRelative = path.relative(cwd, inputDir);
  const outputDir = path.join(cwd, options.outputDir, "symbiosis-assets");

  await fsExtra.ensureDir(outputDir);

  const files = glob
    .sync("**/*.svg", {
      cwd: inputDir,
    })
    .sort((a: string, b: string) => a.localeCompare(b));

  const shouldVerboseLog = process.argv.includes("--log=verbose");
  const logVerbose = shouldVerboseLog ? console.log : () => {};

  if (files.length === 0) {
    console.log(`No SVG files found in ${inputDirRelative}`);
    await generateEmptyIconFiles(outputDir);
  } else {
    await generateIconFiles(
      files,
      inputDir,
      outputDir,
      cwd,
      inputDirRelative,
      logVerbose
    );
  }
}

async function generateEmptyIconFiles(outputDir: string) {
  const typeOutputFilepath = path.join(outputDir, "types.d.ts");
  const jsonOutputFilepath = path.join(outputDir, "iconNames.json");
  const spriteFilepath = path.join(outputDir, "sprite.svg");

  const typeOutputContent = `// This file is generated by npm run build:icons

  declare namespace SymbiosisUI {
    type IconName = string;
    const IconNames: readonly IconName[];
  }
  `;

  await fsExtra.writeFile(typeOutputFilepath, typeOutputContent);
  await fsExtra.writeJson(jsonOutputFilepath, [], { spaces: 2 });
  await fsExtra.writeFile(
    spriteFilepath,
    '<svg xmlns="http://www.w3.org/2000/svg"></svg>'
  );

  console.log(`Generated empty icon files`);
}

async function generateIconFiles(
  files: string[],
  inputDir: string,
  outputDir: string,
  cwd: string,
  inputDirRelative: string,
  logVerbose: (...args: any[]) => void
) {
  const spriteFilepath = path.join(outputDir, "sprite.svg");
  const typeOutputFilepath = path.join(outputDir, "types.d.ts");
  const jsonOutputFilepath = path.join(outputDir, "iconNames.json");

  const currentSprite = await fsExtra
    .readFile(spriteFilepath, "utf8")
    .catch(() => "");
  const currentTypes = await fsExtra
    .readFile(typeOutputFilepath, "utf8")
    .catch(() => "");

  const iconNames = files.map((file: string) => iconName(file));

  const spriteUpToDate = iconNames.every((name: any) =>
    currentSprite.includes(`id=${name}`)
  );
  const typesUpToDate = iconNames.every((name: any) =>
    currentTypes.includes(`"${name}"`)
  );

  if (spriteUpToDate && typesUpToDate) {
    logVerbose(`Icons are up to date`);
    return;
  }

  logVerbose(`Generating sprite for ${inputDirRelative}`);

  const spriteChanged = await generateSvgSprite({
    files,
    inputDir,
    outputPath: spriteFilepath,
  });

  for (const file of files) {
    logVerbose("âœ…", file);
  }
  logVerbose(`Saved to ${path.relative(cwd, spriteFilepath)}`);

  const stringifiedIconNames = iconNames.map((name: any) =>
    JSON.stringify(name)
  );

  const typeOutputContent = `// This file is generated by npm run build:icons

declare namespace SymbiosisUI {
  type IconName =
    | ${stringifiedIconNames.join("\n    | ")}

  const IconNames: readonly IconName[];
}
`;

  const typesChanged = await writeIfChanged(
    typeOutputFilepath,
    typeOutputContent
  );

  logVerbose(`Manifest saved to ${path.relative(cwd, typeOutputFilepath)}`);

  const readmeChanged = await writeIfChanged(
    path.join(outputDir, "README.md"),
    `# Icons

This directory contains SVG icons that are used by the app.

Everything in this directory is generated by \`pnpm run build:icons\`.
`
  );

  await fsExtra.writeJson(jsonOutputFilepath, iconNames, { spaces: 2 });
  logVerbose(`Icon names saved to ${path.relative(cwd, jsonOutputFilepath)}`);

  if (spriteChanged || typesChanged || readmeChanged) {
    console.log(`Generated ${files.length} icons`);
  }
}

function iconName(file: string) {
  return file.replace(/\.svg$/, "");
}

async function generateSvgSprite({
  files,
  inputDir,
  outputPath,
}: {
  files: string[];
  inputDir: string;
  outputPath: string;
}) {
  const symbols = await Promise.all(
    files.map(async (file) => {
      const input = await fsExtra.readFile(path.join(inputDir, file), "utf8");
      const root = parse(input);

      const svg = root.querySelector("svg");
      if (!svg) throw new Error("No SVG element found");

      svg.tagName = "symbol";
      svg.setAttribute("id", iconName(file));
      svg.removeAttribute("xmlns");
      svg.removeAttribute("xmlns:xlink");
      svg.removeAttribute("version");
      svg.removeAttribute("width");
      svg.removeAttribute("height");

      return svg.toString().trim();
    })
  );

  let output = [
    `<?xml version="1.0" encoding="UTF-8"?>`,
    `<!-- This file is generated by npm run build:icons -->`,
    `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">`,
    `<defs>`,
    ...symbols,
    `</defs>`,
    `</svg>`,
    "",
  ].join("\n");

  if (Buffer.byteLength(output, "utf8") < 4096) {
    const placeholderSVG = `
  <symbol id="placeholder" viewBox="0 0 1 1">
    <path d="M0,0 L1,1 M1,0 L0,1" stroke="transparent" />
  </symbol>`.repeat(20);

    output = output.replace("</defs>", `${placeholderSVG}</defs>`);
  }

  return writeIfChanged(outputPath, output);
}

async function writeIfChanged(filepath: string, newContent: string) {
  const currentContent = await fsExtra
    .readFile(filepath, "utf8")
    .catch(() => "");
  if (currentContent === newContent) return false;
  await fsExtra.writeFile(filepath, newContent, "utf8");
  return true;
}
